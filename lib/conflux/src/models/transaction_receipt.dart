import 'package:on_chain/conflux/src/models/log.dart';
import 'package:on_chain/utils/utils/number_utils.dart';
import 'package:blockchain_utils/blockchain_utils.dart';

/// Represents a Conflux transaction receipt.
/// 
/// A receipt is generated after a transaction is executed and included in a block.
/// It contains information about the execution result, gas usage, and logs.
class CFXTransactionReceipt {
  /// The hash of the transaction.
  final String transactionHash;

  /// The index of the transaction within the block.
  final int index;

  /// The hash of the block containing this transaction.
  final String blockHash;

  /// The epoch number of the block containing this transaction.
  final int epochNumber;

  /// The sender's address.
  final String from;

  /// The recipient's address (null for contract creation).
  final String? to;

  /// The gas used by this specific transaction.
  final BigInt gasUsed;

  /// The total gas used in the epoch up to and including this transaction.
  final BigInt? gasCoveredBySponsor;

  /// The gas fee charged to the sender.
  final BigInt gasFee;

  /// The address of the contract created (if this was a contract creation).
  final String? contractCreated;

  /// The list of log entries generated by this transaction.
  final List<CFXLog> logs;

  /// The bloom filter for the logs.
  final String logsBloom;

  /// The root hash of the state trie after this transaction.
  final String stateRoot;

  /// The execution outcome (0 = success, 1 = failure).
  final int outcomeStatus;

  /// Error message if the transaction failed.
  final String? txExecErrorMsg;

  /// The storage collateral occupied by this transaction (in Drip).
  final BigInt? storageCollateralized;

  /// The storage collateral released by this transaction (in Drip).
  final BigInt? storageReleased;

  /// The storage covered by sponsor.
  final BigInt? storageCoveredBySponsor;

  const CFXTransactionReceipt({
    required this.transactionHash,
    required this.index,
    required this.blockHash,
    required this.epochNumber,
    required this.from,
    this.to,
    required this.gasUsed,
    this.gasCoveredBySponsor,
    required this.gasFee,
    this.contractCreated,
    required this.logs,
    required this.logsBloom,
    required this.stateRoot,
    required this.outcomeStatus,
    this.txExecErrorMsg,
    this.storageCollateralized,
    this.storageReleased,
    this.storageCoveredBySponsor,
  });

  /// Creates a [CFXTransactionReceipt] from a JSON map.
  factory CFXTransactionReceipt.fromJson(Map<String, dynamic> json) {
    final logs = (json['logs'] as List?)
            ?.map((log) => CFXLog.fromJson(log))
            .toList() ??
        <CFXLog>[];

    return CFXTransactionReceipt(
      transactionHash: json['transactionHash'],
      index: PluginIntUtils.hexToInt(json['index']),
      blockHash: json['blockHash'],
      epochNumber: PluginIntUtils.hexToInt(json['epochNumber']),
      from: json['from'],
      to: json['to'],
      gasUsed: BigintUtils.parse(json['gasUsed']),
      gasCoveredBySponsor: json['gasCoveredBySponsor'] != null
          ? BigintUtils.parse(json['gasCoveredBySponsor'])
          : null,
      gasFee: BigintUtils.parse(json['gasFee']),
      contractCreated: json['contractCreated'],
      logs: logs,
      logsBloom: json['logsBloom'],
      stateRoot: json['stateRoot'],
      outcomeStatus: PluginIntUtils.hexToInt(json['outcomeStatus']),
      txExecErrorMsg: json['txExecErrorMsg'],
      storageCollateralized: json['storageCollateralized'] != null
          ? BigintUtils.parse(json['storageCollateralized'])
          : null,
      storageReleased: json['storageReleased'] != null
          ? BigintUtils.parse(json['storageReleased'])
          : null,
      storageCoveredBySponsor: json['storageCoveredBySponsor'] != null
          ? BigintUtils.parse(json['storageCoveredBySponsor'])
          : null,
    );
  }

  /// Checks if the transaction was successful.
  bool get isSuccess => outcomeStatus == 0;

  /// Checks if the transaction failed.
  bool get isFailed => outcomeStatus != 0;

  /// Converts this receipt to a JSON map.
  Map<String, dynamic> toJson() {
    return {
      'transactionHash': transactionHash,
      'index': '0x${index.toRadixString(16)}',
      'blockHash': blockHash,
      'epochNumber': '0x${epochNumber.toRadixString(16)}',
      'from': from,
      if (to != null) 'to': to,
      'gasUsed': '0x${gasUsed.toRadixString(16)}',
      if (gasCoveredBySponsor != null)
        'gasCoveredBySponsor': '0x${gasCoveredBySponsor!.toRadixString(16)}',
      'gasFee': '0x${gasFee.toRadixString(16)}',
      if (contractCreated != null) 'contractCreated': contractCreated,
      'logs': logs.map((log) => log.toJson()).toList(),
      'logsBloom': logsBloom,
      'stateRoot': stateRoot,
      'outcomeStatus': '0x${outcomeStatus.toRadixString(16)}',
      if (txExecErrorMsg != null) 'txExecErrorMsg': txExecErrorMsg,
      if (storageCollateralized != null)
        'storageCollateralized': '0x${storageCollateralized!.toRadixString(16)}',
      if (storageReleased != null)
        'storageReleased': '0x${storageReleased!.toRadixString(16)}',
      if (storageCoveredBySponsor != null)
        'storageCoveredBySponsor': '0x${storageCoveredBySponsor!.toRadixString(16)}',
    };
  }

  @override
  String toString() {
    return 'CFXTransactionReceipt{transactionHash: $transactionHash, epochNumber: $epochNumber, from: $from, to: $to, outcomeStatus: $outcomeStatus}';
  }
}

